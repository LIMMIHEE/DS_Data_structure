선택 정렬이 가장 점수가 낮다. 
다만 선택 정렬보다 오래 걸리는건 버블 정렬이다. 

버블 - 정렬이 되면 더이상 반복을 하지 않는다
데이터 이동횟수가 많음, 선택 정렬보다 오래 걸림
주기억 장치에서의 데이터 이동에 시간이 많이 걸린다.
 - 명령 10개 처리하는 시간보다 많이 걸릴 수 있음.
더군다나 보조 기억 장치와의 데이터 이동이 더 많은 시간이 걸린다.
	- 보조기억장치에서 보조기억장치로 옮기는 건 더욱 많이 걸림.( 제일 느림 )
보조기억 장치와 주기억장치에서의 데이터 이동도 느림.
주기억장치에서 주기억장치로 이동하는 것은 비교가 안될 정도로 빠름. ( 하지만 CPU가 명령처리 하는 것에 비해 오래걸린다. )
캐시메모리에서 명령을 처리하려면 MBR(메모리 버퍼 레지스터)를 거쳐[데이터, 명령이 들어감] 제어장치(Control unit)로 가서 연산장치로 가게된다.[데이터 들어감]
	- 얘네들은 CPU안에 있기 때문에 빠름


선택정렬 - 데이터가 정렬되어있어도 안되있어도 데이터의 이동 횟수는 변하지 않는다.
오른쪽으로 한칸씩 가다가 데이터를 넣는데. 데이터 이동이 있지만 버블 만크 있지는 않다. ( break로 인해서 )
선택, 버블, 삽입 셋다 n제곱 이지만 실제로 돌린다면 차이가 있다. 


** 좋은 방법
퀵 n*log(n)
담점 : 이미 정렬되어있을 수록 반복횟수가 많아짐( 돌리면 알 수 있음)
	- 피봇으로 쓸 값을 가운데로 좌우 재배치하면서 사용. 
데이터가 어느정도 정렬이 되어있다 치면 피봇을 정할 필요는 없지만 단점을 고치기 위해 피봇을 사용( 개선된 sortAlogExTime 확인 )

힙정렬 
단점 : 없음	배열 초기 상태에 따라 반복횟수가 큰 차이가 없음.


기수(버킷)정렬 : 데이터 이동이 병합정렬보다 적음.
d*n?
동적 할당을 받음

쉘 정렬
산술적으로는 시간 복잡도가 n*log2n 이지만 실질적으로는 n*(o)n과 비슷하다.

병합 정렬
다른 것보다 더 걸리는 이유 : 데이터 이동횟수가 많아서 그럼. 다 정렬된 데이터를 다른 배열에 넣고 다시 원래 위치에 옮기는데 시간이 걸리기 떄문.
동적 할당을 받음.
시간 복잡도 : n* log 2n





내부 정렬과 외부 정렬
외부 정렬 방법 한가지
	- 정렬이 되어있어야 한다.

들어오는 길이 2개 ( 2- way merge )( 병합 )
보조기억 장치를 사용해서 대량의 데이터를 정렬할떄 이런 방법을 사용?

내부정렬 5가지의 방법
삽입 법 -삽입, 쉘
교환법 - 버블( 교환 개많음 ), 퀵( 최소로 교환 한다 )
선택법 - 선택 정렬, 힙 정렬( 반복 횟수가 적음, 선택 정렬의 가장 큰 값을 찾는 것보다 휠씬 적게 반복 되기 때문 )
병합법 - 병합 정렬
분배법 - 기수정렬, 버킷 정렬( 기수 정렬은 버킷 정렬을 사용하지만 1의 자리 100의 자리 1000의 자리가 우선적으로 중요하기 때문에 기수가 된다. ) 라지 정렬? 도 버킷을 사용하긴 함





